\subsection*{experimental-mocking-runtime-dispatch}
Note that with this approach the
\code{{Base,Mock,Stub,Combined,}InteractionDeclaration}
types are renamed to
\code{CompileTime{Base,Mock,Stub,Combined,}InteractionDeclaration}
to distinguish them
from the \textit{RuntimeInteractionDeclaration} types.

\paragraph*{packages/config/src/hooks/interaction/compile-time.ts}
\begin{minted}{typescript}
import * as BabelTypes from '@babel/types';

import { InternalConfig } from '../..';

export interface CompileTimeBaseInteractionDeclaration {
  mockObject: BabelTypes.Expression;
  args: (BabelTypes.Expression | BabelTypes.SpreadElement)[];
}
export interface CompileTimeMockInteractionDeclaration
  extends CompileTimeBaseInteractionDeclaration {
  kind: 'mock';
  cardinality: BabelTypes.Expression;
}
export interface CompileTimeStubInteractionDeclaration
  extends CompileTimeBaseInteractionDeclaration {
  kind: 'stub';
  returnValue: BabelTypes.Expression;
}
export interface CompileTimeCombinedInteractionDeclaration
  extends CompileTimeBaseInteractionDeclaration {
  kind: 'combined';
  cardinality: BabelTypes.Expression;
  returnValue: BabelTypes.Expression;
}
export type CompileTimeInteractionDeclaration =
  | CompileTimeMockInteractionDeclaration
  | CompileTimeStubInteractionDeclaration
  | CompileTimeCombinedInteractionDeclaration;

export type InteractionVerificationPostProcessor = (
  t: typeof BabelTypes,
  config: InternalConfig,
) => (mockObject: BabelTypes.Expression) => BabelTypes.Statement;
\end{minted}

\paragraph*{packages/config/src/hooks/interaction/runtime.ts}
\begin{minted}{typescript}
export interface RuntimeBaseInteractionDeclaration {
  mockObject: any;
  /**
   * For a call like `mock.method()`,
   * mockObject will be just `mock`,
   * and methodName will be `'method'`.
   */
  methodName?: string;
  args: any[];
}
export interface RuntimeMockInteractionDeclaration
  extends RuntimeBaseInteractionDeclaration {
  kind: 'mock';
  cardinality: number;
}
export interface RuntimeStubInteractionDeclaration
  extends RuntimeBaseInteractionDeclaration {
  kind: 'stub';
  returnValue: any;
}
export interface RuntimeCombinedInteractionDeclaration
  extends RuntimeBaseInteractionDeclaration {
  kind: 'combined';
  cardinality: number;
  returnValue: any;
}
export type RuntimeInteractionDeclaration =
  | RuntimeMockInteractionDeclaration
  | RuntimeStubInteractionDeclaration
  | RuntimeCombinedInteractionDeclaration;

export type InteractionDeclarationRuntimeAdapter = (
  declaration: RuntimeInteractionDeclaration,
) => void;
export type InteractionVerificationRuntimeAdapter = (mockObject: any) => void;
\end{minted}

\paragraph*{packages/preset-sinon-mocks/src/index.ts}
\begin{minted}{typescript}
import { InteractionVerificationPostProcessor } from '@spockjs/config';

export const assertionPostProcessors = [];

export const interactionRuntimeAdapter =
  '@spockjs/interaction-runtime-adapter-sinon';
export const interactionVerificationPostProcessors:
  InteractionVerificationPostProcessor[] = [];
\end{minted}

\paragraph*{packages/preset-jest-mocks/src/index.ts}
\begin{minted}{typescript}
import { InteractionVerificationPostProcessor } from '@spockjs/config';

export const assertionPostProcessors = [];

export const interactionRuntimeAdapter =
  '@spockjs/interaction-runtime-adapter-jest';
export const interactionVerificationPostProcessors:
  InteractionVerificationPostProcessor[] = [];
\end{minted}

% TODO
