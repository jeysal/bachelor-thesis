\section{Jest}
Jest only provides a few simple and non-chainable mock function matchers,
such as \code{toBeCalled()} and \code{toBeCalledWith(arg0, arg1)},
out of the box.
However, Jest mocks do record and provide access to
all of the calls to them that occurred via
\code{mockFn.mock.calls}.
We can build our own simplistic call matching logic
on top of that interface,
although it means that we will need to
generate a lot more and a lot more complex code
compared to the Sinon interaction processor.

The basic idea of what the generated code should do
to be able to memorize interaction declarations
and later access their return values for stubbing
and verify them by comparing to the actual calls that occurred for mocking
is the following:
\begin{enumerate}
  \item Store all declarations
    --- including arguments, cardinality and return value ---
    in an array hidden inside the mock.
    In this case, the key to access the array on the mock will be:
    \begin{minted}[fontsize=\footnotesize]{javascript}
const symbol = 'Symbol.for("spockjsInteractDecls")';
    \end{minted}
  \item When the function is called,
    stub out its return value by
    looking for an interaction declaration
    with the correct arguments in the store
    and using the return value specified in that declaration.
  \item When the mock is verified,
    iterate through those of its interaction declarations
    that have a cardinality specified
    and for each one of them,
    ensure that exactly the specified number of calls
    with the correct arguments has occurred.
\end{enumerate}

\subsection{Declaration}
The Jest interaction processor generates
not just a single statement like the one for Sinon,
but a block statement composed of two parts:
The \textit{declareInteraction} template and
the \textit{initStub} template.

The \textit{declareInteraction} template first
performs a sanity check to ensure that
the \textit{mockObject} from the user's interaction declaration
is actually a Jest mock function and
prints an error if that is not the case.
Afterwards, it adds a declaration to the store of the mock,
if necessary initializing the store with an empty array beforehand:
\begin{minted}{javascript}
const declareInteraction = template(`
  // ...
  MOCK[${symbol}] = [
    ...(MOCK[${symbol}] || []),
    {
      args: ARGS,
      cardinality: CARDINALITY,
      returnValue: RETURN_VALUE,
    }
  ];
`);
\end{minted}
When the template is instantiated for a concrete interaction declaration,
the mock, args, cardinality, and return value placeholders
are filled with the nodes from the interaction declaration,
with the possibility of one of the latter two being \code{undefined} identifiers
if the declaration was not a combined interaction declaration.

The \textit{initStub} template uses the \textit{mockImplementation}
to inject behavior into the mock function.
Whenever it is called after this initialization,
it will look for an interaction declaration
with matching arguments in the store
and return the associated return value for that interaction,
defaulting to \code{undefined} if no declaration matches:
\begin{minted}{javascript}
const initStub = template(`
  STUB.mockImplementation(
    (...actual) =>
      (
        STUB[${symbol}].find(({ args: expected }) =>
          ${deepStrictEqual}(actual, expected),
        ) || {}
      ).returnValue,
  );
`);
\end{minted}
The \textit{deepStrictEqual} helper is an imported function
that compares the contents of object and array structures
instead of their shallow identities,
so that for instance the following declaration and call would match:
\begin{minted}{javascript}
stub: s({}) >> 42;
s({}) === 42;
\end{minted}

\subsection{Verification}
The \textit{verify} template also performs the sanity check
to ensure that given value is actually a Jest mock function
and afterwards applies the verification algorithm as described earlier:
\begin{enumerate}
  \item Retrieve the interaction declarations from the mock.
  \item Filter out all the interaction declarations that have no cardinality
    (i.e. that are for stubbing only).
  \item For each remaining declaration:
    \begin{enumerate}
      \item Retrieve the actual occurred calls from the mock.
      \item Filter out calls with arguments that differ from
        the \textit{args} of the interaction declaration.
      \item Count the remaining calls.
      \item If the count is not equal to
        the \textit{cardinality} of the interaction declaration,
        throw an error.
    \end{enumerate}
\end{enumerate}

The following template implements this algorithm:
\begin{minted}[fontsize=\scriptsize]{javascript}
const verify = template(`
  // ...
  (MOCK[${symbol}] || [])
    .filter(({ cardinality }) => cardinality != null)
    .forEach(({ args: expected, cardinality: expectedTimes }) => {
      const __spockjs_actualTimes = MOCK.mock.calls.filter(actual =>
        ${deepStrictEqual}([...actual], [...expected]),
      ).length;
      if (__spockjs_actualTimes !== expectedTimes) {
        const __spockjs_args = ${prettyFormat}(expected);
        throw new Error(
          \`Expected \${expectedTimes} call(s) to mock '\${MOCK_NAME}' \` +
            \`with arguments \${__spockjs_args}, \` +
            \`but received \${__spockjs_actualTimes} such call(s).\`,
        );
      }
    });
`);
\end{minted}

When instantiating the template,
the \textit{MOCK\_NAME} placeholder
will be replaced with a string literal
containing the printed
\textit{mockObject} AST node.
The error message is thus made more useful
by referring to the mock like it was specified
in the original interaction declaration.
For example, the code
\begin{minted}{javascript}
mock: 1 * mock();
verify: (true ? mock: other);
\end{minted}
would result in the error message:
\begin{minted}{text}
Expected 1 call(s) to mock '(true ? mock: other)' ...
\end{minted}

The full code of \textit{@spockjs/interaction-processor-jest-mocks},
including the template instantiation,
is included in the appendix.
