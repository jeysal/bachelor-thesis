\section{Multi-library support}
Unlike the common operation of parsing interaction declarations,
generating statements that perform the declaration after parsing
as well as generating statements that perform the verification
are more complex tasks that require proper abstractions in order
to work with multiple supported mocking libraries.

\subsection{Purpose}
There are multiple reasons why we want to provide support
for different mocking libraries as opposed to
supporting just a single one or even shipping our own.

\paragraph{Distinctive library features}
Users may wish to use special functionality
provided by their mocking library of choice
alongside the usage through spockjs.
This is particularly common for libraries
that are included in a test runner and
designed to integrate well with it.

For example, Jest \autocite{JestGithub}
allows replacing the module \code{module.js}
with a mock implementation \code{__mocks__/module.js}
wherever the module is used by simply
calling \code{jest.mock('./module.js')} in a test.
\autocite{JestMockFunctions}

\paragraph{Avoiding technology lock-in}
Forcing the usage of a specific mocking library,
possibly even one that is only used for spockjs,
would also significantly increase the severity of
technology lock-in imposed by spockjs
by preventing users from returning to
direct usage of the mocking library
if they wish to stop using spockjs.

Indeed, avoiding this has been a focus
for the implementation of assertion blocks.
The spockjs documentation has a section
dedicated to an automated escape hatch
that allows users to transform \textit{(codemod)}
all of their tests to make conventional assertion calls,
allowing them to drop spockjs without first
undergoing an enormous refactoring effort.
\autocite{SpockjsGithub}

\subsection{Library selection}
Telling spockjs which mocking library to use should
take no more than enabling a preset in the configuration.
However, at least in the first version,
spockjs does not aim to be fully opaque
by hiding the mocking library in use as an `implementation detail'.
This means that users will still need to be aware
about the mocking library in use.

For example, interaction declarations
do not have to carry the same semantics
regardless of which mocking library is used.
If, for instance, declaring the same interaction twice
is handled by overriding the first interaction by one backing library,
another library may instead handle it by `queueing' the declarations
and expecting the calls to occur in succession.

The reasons for this decision are
\begin{itemize}
  \item that ensuring consistent behavior across mocking libraries would mean
    reimplementing large parts of the libraries ourselves,
    using the library primitives but not features
    which may diverge for different libraries,
    such as their interaction matching capabilities,
  \item that future advanced features of the spockjs interaction block syntax
    may not be supported with all mocking libraries, and
  \item that users would still need to instantiate mock objects themselves,
    so the backing library would not be fully opaque anyway.
\end{itemize}
