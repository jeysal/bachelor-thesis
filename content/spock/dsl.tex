\section{Domain-specific languages}
A \textit{domain-specific language (DSL)},
as opposed to a general-purpose language like C or Java,
targets a very specific application purpose.
Examples from various areas of software development are:
\begin{itemize}
  \item \textit{Markdown} for text formatting, \autocite{MarkdownIntro}
  \item the \textit{Gradle Build Language} for build configuration, \autocite{GradleWritingBuildScripts} and
  \item the \textit{Spock specification language} for test cases. \autocite{SpockFrameworkDoc}
\end{itemize}

These three languages can be organized in three rough categories,
distinguished by the way they are implemented:
\begin{enumerate}
  \item Standalone DSLs such as Markdown,
  \item entirely `userspace' DSLs such as the Gradle Build Language, and
  \item as a middle ground, custom compilation DSLs such as the Spock specification language.
\end{enumerate}

\paragraph{Standalone DSLs}
Standalone DSLs are implemented by defining a wholly new
lexical and syntactical grammar and the language semantics.
One can then use a parser generator to obtain a parser for the language
and include in in their software.

The major disadvantages of this approach for a testing DSL are
\begin{itemize}
  \item that the language would have to be enormously complex
    in order to be able to replace the regular Groovy language
    \begin{itemize}
      \item or it would have to be embedded in strings in the test cases, and
    \end{itemize}
  \item that there would be no tooling support for the language
    that provides autocompletion, formatting, error checking, and other assistance
    like there is for widespread existing languages.
\end{itemize}

\paragraph{Userspace DSLs}
TODO

\paragraph{Custom compilation DSLs}
TODO
